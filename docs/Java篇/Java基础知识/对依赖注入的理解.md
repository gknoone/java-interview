# 对于依赖注入的理解
返回[README.md](./../../README.md)

---
目录

<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->

* [引用](#引用)
* [返回目录](#返回目录)

<!-- /code_chunk_output -->

---

> IOC是思想，DI是一种实现方式

如果一个类A的功能实现需要借助于类B，那么就称类B是类A的`依赖`，如果在类A的`内部去实例化`类B，那么两者之间会出现`较高的耦合`，一旦类B出现了问题，类A也需要进行改造，如果这样的情况较多，每个类之间都有很多依赖，那么就会出现牵一发而动全身的情况，程序会极难维护，并且很容易出现问题。

要解决这个问题，就要把A类对B类的控制权抽离出来，交给一个第三方去做，把控制权反转给第三方，就称作控制反转（IOC+Inversion+Of+Control）。控制反转是一种思想，是能够解决问题的一种可能的结果，而依赖注入（Dependency+Injection）就是其最典型的实现方法。

由第三方（我们称作IOC容器）来控制依赖，把他通过`构造函数`、`属性`或者`工厂模式`等方法，注入到类A内，这样就极大程度的对类A和类B进行了解耦。


---
## 引用
[]()

---
## 返回目录
[README.md](./../../README.md)
