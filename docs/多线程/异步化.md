# 异步化

## 1. 同步和异步，阻塞和非阻塞

同步和异步关注的是**结果消息的通信机制**

- 同步:同步的意思就是调用方需要主动等待结果的返回
- 异步:异步的意思就是不需要主动等待结果的返回，而是通过其他手段比如，状态通知，回调函数等。

阻塞和非阻塞主要关注的是**等待结果返回调用方的状态**

- 阻塞:是指结果返回之前，当前线程被挂起，不做任何事
- 非阻塞:是指结果在返回之前，线程可以做一些其他事，不会被挂起

## 2. 同步阻塞 PK 异步非阻塞

当我们的线程发生一次rpc调用或者http调用，又或者其他的一些耗时的IO调用，发起之后，如果是同步阻塞，我们的这个线程就会被阻塞挂起，直到结果返回，试想一下如果IO调用很频繁那我们的CPU使用率其实是很低很低。正所谓是物尽其用，既然CPU的使用率被IO调用搞得很低，那我们就可以使用异步非阻塞，当发生IO调用时我并不马上关心结果，我只需要把回调函数写入这次IO调用，我这个时候线程可以继续处理新的请求，当IO调用结束结束时，会调用回调函数。而我们的线程始终处于忙碌之中，这样就能做更多的有意义的事了。

这里首先要说明的是，异步化不是万能，异步化并不能缩短你整个链路调用时间长的问题，但是他能极大的提升你的最大qps。一般我们的业务中有两处比较耗时:

- cpu: cpu耗时指的是我们的一般的业务处理逻辑，比如一些数据的运算，对象的序列化。这些异步化是不能解决的，得需要靠一些算法的优化，或者一些高性能框架。
- iowait: io耗时就像我们上面说的,一般发生在网络调用，文件传输中等等，这个时候线程一般会挂起阻塞。而我们的异步化通常用于解决这部分的问题。

## 3. 哪些可以异步化？

- servlet异步化,springmvc异步化
- rpc调用如(dubbo,thrift),http调用异步化
- 数据库调用，缓存调用异步化