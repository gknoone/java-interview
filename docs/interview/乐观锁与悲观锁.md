
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->

* [乐观锁](#乐观锁)
* [悲观锁](#悲观锁)
* [乐观锁和悲观锁的使用场景](#乐观锁和悲观锁的使用场景)
* [乐观锁常见的两种实现方式](#乐观锁常见的两种实现方式)
* [乐观锁的缺点](#乐观锁的缺点)
* [CAS与synchronized的使用情景](#cas与synchronized的使用情景)

<!-- /code_chunk_output -->

## 乐观锁
总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是**在更新的时候会判断一下在此期间别人有没有去更新这个数据**，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。
## 悲观锁
总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以**每次在拿数据的时候都会上锁**，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。

## 乐观锁和悲观锁的使用场景

- 乐观锁：写少
- 悲观锁：写多


## 乐观锁常见的两种实现方式

1. 版本号机制
    - 一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。
2. CAS算法
    - compare and swap（比较与交换）
    - 无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫**非阻塞同步**（Non-blocking Synchronization）
    - CAS算法涉及到三个操作数
      - 需要读写的内存值 V
      - 进行比较的值 A
      - 拟写入的新值 B
      - 当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。


## 乐观锁的缺点
1. **ABA 问题**
    - 如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，**那CAS操作就会误认为它从来没有被修改过**。这个问题被称为CAS操作的 "ABA"问题。
2. **循环时间长开销大**
    - **自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。**
3. **只能保证一个共享变量的原子操作**
    - CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。
    - 但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。

## CAS与synchronized的使用情景
- (写少的场景)对于资源竞争较少（线程冲突较轻）的情况，**使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源**；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。
- (写多的场景)对于资源竞争严重（线程冲突严重）的情况，**CAS自旋的概率会比较大，从而浪费更多的CPU资源**，效率低于synchronized。
